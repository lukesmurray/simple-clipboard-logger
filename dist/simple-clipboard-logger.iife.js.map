{"version":3,"file":"simple-clipboard-logger.iife.js","sources":["../src/eventLoggers/consoleEventLogger.ts","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/utils/cryptoPolyfill.ts","../node_modules/nanoid/index.prod.js","../src/metadataProviders/dateMetadataProvider.ts","../src/metadataProviders/hrefMetadataProvider.ts","../src/metadataProviders/selectionIdMetadataProvider.ts","../node_modules/@babel/runtime/helpers/esm/createClass.js","../src/SimpleClipboardLogger.ts","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js"],"sourcesContent":["import { EventLogger } from \"../types/EventLogger\";\n\nexport const consoleEventLogger: EventLogger = (metadata) => {\n  console.log(metadata);\n};\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","if (!window.crypto) {\n  //@ts-expect-error: this is a polyfill for IE11\n  window.crypto = window.msCrypto;\n}\n","// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nif (false) {\n  // All bundlers will remove this block in the production bundle.\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","import { MetadataProvider } from \"../types/MetadataProvider\";\n\nexport const dateMetadataProvider: MetadataProvider = () => {\n  return { date: new Date().toISOString() };\n};\n","import { MetadataProvider } from \"../types/MetadataProvider\";\n\nexport const hrefMetadataProvider: MetadataProvider = (e, prev) => {\n  return {\n    [`${prev.eventType}Href`]: window.location.href,\n  };\n};\n","import \"../utils/cryptoPolyfill\";\nimport { nanoid } from \"nanoid\";\nimport { MetadataProvider } from \"../types/MetadataProvider\";\n\nexport const selectionIdMetadataProvider: () => MetadataProvider = () => {\n  let selectionId: string | undefined;\n\n  return (e, prev) => {\n    if (prev.eventType === \"copy\" || prev.eventType === \"cut\") {\n      selectionId = nanoid();\n    }\n    return {\n      selectionId,\n    };\n  };\n};\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","import { DefaultMetadata } from \"./types/DefaultMetadata\";\nimport { EventFilter } from \"./types/EventFilter\";\nimport { EventLogger } from \"./types/EventLogger\";\nimport { MetadataProvider } from \"./types/MetadataProvider\";\n\nexport class SimpleClipboardLogger {\n  private metadataProviders: MetadataProvider[] = [];\n  private eventFilters: EventFilter[] = [];\n  private eventLoggers: EventLogger[] = [];\n\n  constructor() {\n    this.onCopy = this.onCopy.bind(this);\n    this.onCut = this.onCut.bind(this);\n    this.onPaste = this.onPaste.bind(this);\n  }\n\n  addMetadataProvider(metadataProvider: MetadataProvider) {\n    this.metadataProviders.push(metadataProvider);\n  }\n\n  removeMetadataProvider(metadataProvider: MetadataProvider) {\n    const index = this.metadataProviders.indexOf(metadataProvider);\n    if (index > -1) {\n      this.metadataProviders.splice(index, 1);\n    }\n  }\n\n  addEventFilter(eventFilter: EventFilter) {\n    this.eventFilters.push(eventFilter);\n  }\n\n  removeEventFilter(eventFilter: EventFilter) {\n    const index = this.eventFilters.indexOf(eventFilter);\n    if (index > -1) {\n      this.eventFilters.splice(index, 1);\n    }\n  }\n\n  addEventLogger(eventLogger: EventLogger) {\n    this.eventLoggers.push(eventLogger);\n  }\n\n  removeEventLogger(eventLogger: EventLogger) {\n    const index = this.eventLoggers.indexOf(eventLogger);\n    if (index > -1) {\n      this.eventLoggers.splice(index, 1);\n    }\n  }\n\n  addEventTarget(\n    target: EventTarget,\n    {\n      copy = true,\n      cut = true,\n      paste = true,\n    }: {\n      copy?: boolean;\n      cut?: boolean;\n      paste?: boolean;\n    } = {},\n  ) {\n    // add event listeners\n    if (copy) {\n      target.addEventListener(\"copy\", this.onCopy as any);\n    }\n\n    if (cut) {\n      target.addEventListener(\"cut\", this.onCut as any);\n    }\n\n    if (paste) {\n      target.addEventListener(\"paste\", this.onPaste as any);\n    }\n\n    // create unsubscribe func\n    const unsubscribe = () => {\n      if (copy) {\n        target.removeEventListener(\"copy\", this.onCopy as any);\n      }\n      if (cut) {\n        target.removeEventListener(\"cut\", this.onCut as any);\n      }\n      if (paste) {\n        target.removeEventListener(\"paste\", this.onPaste as any);\n      }\n    };\n\n    // return the unsubscribe func\n    return unsubscribe;\n  }\n\n  private handleCopyOrCut(e: ClipboardEvent, eventType: \"copy\" | \"cut\") {\n    if (this.isFiltered(e)) {\n      return;\n    }\n    const defaultMetadata: DefaultMetadata = {\n      eventType: eventType,\n      data: {\n        \"text/plain\": window.getSelection()?.toString(),\n      },\n    };\n\n    const metadata = this.getMetadata(e, defaultMetadata);\n\n    this.logEvent({ ...defaultMetadata, ...metadata });\n  }\n\n  private onCopy(e: ClipboardEvent) {\n    this.handleCopyOrCut(e, \"copy\");\n  }\n\n  private onCut(e: ClipboardEvent) {\n    this.handleCopyOrCut(e, \"copy\");\n  }\n\n  private onPaste(e: ClipboardEvent) {\n    if (this.isFiltered(e)) {\n      return;\n    }\n    const defaultMetadata: DefaultMetadata = {\n      eventType: \"paste\",\n      data: {\n        \"text/html\": e.clipboardData?.getData(\"text/html\"),\n        \"text/plain\": e.clipboardData?.getData(\"text/plain\"),\n      },\n    };\n\n    const metadata = this.getMetadata(e, defaultMetadata);\n\n    this.logEvent({ ...defaultMetadata, ...metadata });\n  }\n\n  private isFiltered(e: ClipboardEvent) {\n    return !this.eventFilters.every((f) => f(e));\n  }\n\n  private getMetadata(e: ClipboardEvent, defaultMetadata: DefaultMetadata) {\n    return this.metadataProviders.reduce(\n      (prev, provider) =>\n        typeof provider === \"function\" ? { ...prev, ...provider(e, prev as any) } : { ...prev, ...provider },\n      defaultMetadata,\n    );\n  }\n\n  private logEvent(metadata: any) {\n    this.eventLoggers.forEach((logger) => logger(metadata));\n  }\n}\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}"],"names":["metadata","console","log","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","window","crypto","msCrypto","date","Date","toISOString","e","prev","eventType","location","href","selectionId","size","id","bytes","getRandomValues","Uint8Array","byte","toString","toUpperCase","nanoid","_defineProperties","target","props","i","length","descriptor","SimpleClipboardLogger","instance","Constructor","TypeError","onCopy","this","bind","onCut","onPaste","protoProps","staticProps","metadataProvider","metadataProviders","push","index","indexOf","splice","eventFilter","eventFilters","eventLogger","eventLoggers","copy","cut","paste","addEventListener","unsubscribe","removeEventListener","_this","isFiltered","defaultMetadata","data","getSelection","_window$getSelection","getMetadata","logEvent","handleCopyOrCut","clipboardData","_e$clipboardData","getData","_e$clipboardData2","every","f","reduce","provider","forEach","logger","prototype"],"mappings":"mDAEO,uDAAwC,SAACA,GAC9CC,QAAQC,IAAIF,MCHC,SAASG,EAAgBC,EAAKC,EAAKC,UAC5CD,KAAOD,EACTG,OAAOC,eAAeJ,EAAKC,EAAK,CAC9BC,MAAOA,EACPG,YAAY,EACZC,cAAc,EACdC,UAAU,IAGZP,EAAIC,GAAOC,EAGNF,ECZJQ,OAAOC,SAEVD,OAAOC,OAASD,OAAOE,UC0EzB,yDC1EsD,iBAC7C,CAAEC,MAAM,IAAIC,MAAOC,qCCD0B,SAACC,EAAGC,yBAElDA,EAAKC,kBAAkBR,OAAOS,SAASC,mCCAoB,eAC7DC,SAEG,SAACL,EAAGC,SACc,SAAnBA,EAAKC,WAA2C,QAAnBD,EAAKC,YACpCG,EHmEO,mBAACC,yDAAO,GACfC,EAAK,GACLC,EAAQb,OAAOc,gBAAgB,IAAIC,WAAWJ,IAG3CA,KAAQ,KAMTK,EAAqB,GAAdH,EAAMF,GAGfC,GAFEI,EAAO,GAEHA,EAAKC,SAAS,IACXD,EAAO,IAETA,EAAO,IAAIC,SAAS,IAAIC,cACtBF,EAAO,GACV,IAEA,WAGHJ,EG3FWO,IAET,CACLT,YAAAA,OCZN,SAASU,EAAkBC,EAAQC,OAC5B,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,KACjCE,EAAaH,EAAMC,GACvBE,EAAW7B,WAAa6B,EAAW7B,aAAc,EACjD6B,EAAW5B,cAAe,EACtB,UAAW4B,IAAYA,EAAW3B,UAAW,GACjDJ,OAAOC,eAAe0B,EAAQI,EAAWjC,IAAKiC,ukBCDrCC,2BCLE,SAAyBC,EAAUC,QAC1CD,aAAoBC,SAClB,IAAIC,UAAU,yEDI0B,0BACV,0BACA,SAG/BC,OAASC,KAAKD,OAAOE,KAAKD,WAC1BE,MAAQF,KAAKE,MAAMD,KAAKD,WACxBG,QAAUH,KAAKG,QAAQF,KAAKD,MDHtB,IAAsBH,EAAaO,EAAYC,SAAzBR,IAAaO,oCCMhD,SAAoBE,QACbC,kBAAkBC,KAAKF,yCAG9B,SAAuBA,OACfG,EAAQT,KAAKO,kBAAkBG,QAAQJ,GACzCG,GAAS,QACNF,kBAAkBI,OAAOF,EAAO,iCAIzC,SAAeG,QACRC,aAAaL,KAAKI,oCAGzB,SAAkBA,OACVH,EAAQT,KAAKa,aAAaH,QAAQE,GACpCH,GAAS,QACNI,aAAaF,OAAOF,EAAO,iCAIpC,SAAeK,QACRC,aAAaP,KAAKM,oCAGzB,SAAkBA,OACVL,EAAQT,KAAKe,aAAaL,QAAQI,GACpCL,GAAS,QACNM,aAAaJ,OAAOF,EAAO,iCAIpC,SACEnB,uEASI,OAPF0B,KAAAA,oBACAC,IAAAA,oBACAC,MAAAA,gBAQEF,GACF1B,EAAO6B,iBAAiB,OAAQnB,KAAKD,QAGnCkB,GACF3B,EAAO6B,iBAAiB,MAAOnB,KAAKE,OAGlCgB,GACF5B,EAAO6B,iBAAiB,QAASnB,KAAKG,aAIlCiB,EAAc,WACdJ,GACF1B,EAAO+B,oBAAoB,OAAQC,EAAKvB,QAEtCkB,GACF3B,EAAO+B,oBAAoB,MAAOC,EAAKpB,OAErCgB,GACF5B,EAAO+B,oBAAoB,QAASC,EAAKnB,iBAKtCiB,iCAGD,SAAgB9C,EAAmBE,aACrCwB,KAAKuB,WAAWjD,QAGdkD,EAAmC,CACvChD,UAAWA,EACXiD,KAAM,wBACUzD,OAAO0D,mCAAPC,EAAuBzC,aAInC9B,EAAW4C,KAAK4B,YAAYtD,EAAGkD,QAEhCK,gBAAcL,GAAoBpE,2BAGjC,SAAOkB,QACRwD,gBAAgBxD,EAAG,6BAGlB,SAAMA,QACPwD,gBAAgBxD,EAAG,+BAGlB,SAAQA,eACV0B,KAAKuB,WAAWjD,QAGdkD,EAAmC,CACvChD,UAAW,QACXiD,KAAM,uBACSnD,EAAEyD,kCAAFC,EAAiBC,QAAQ,oCACxB3D,EAAEyD,kCAAFG,EAAiBD,QAAQ,gBAIrC7E,EAAW4C,KAAK4B,YAAYtD,EAAGkD,QAEhCK,gBAAcL,GAAoBpE,+BAGjC,SAAWkB,UACT0B,KAAKa,aAAasB,OAAM,SAACC,UAAMA,EAAE9D,iCAGnC,SAAYA,EAAmBkD,UAC9BxB,KAAKO,kBAAkB8B,QAC5B,SAAC9D,EAAM+D,iBACiC/D,GAAlB,mBAAb+D,EAAwCA,EAAShE,EAAGC,GAA+B+D,KAC5Fd,2BAII,SAASpE,QACV2D,aAAawB,SAAQ,SAACC,UAAWA,EAAOpF,SDtI3CgD,GAAYf,EAAkBQ,EAAY4C,UAAWrC,GACrDC,GAAahB,EAAkBQ,EAAaQ"}